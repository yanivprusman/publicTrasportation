{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useEffect, useRef } from 'react';\nimport { useMap } from 'react-leaflet';\nimport L from 'leaflet';\n\n/**\n * Component that handles map effects like fitting to bounds\n */\nconst MapEffect = ({\n  routeShape\n}) => {\n  _s();\n  const map = useMap();\n  const fittedRef = useRef(false);\n  const routeIdRef = useRef(null);\n  const processingRef = useRef(false);\n\n  // Generate a unique ID for the current route to detect changes\n  const currentRouteId = routeShape ? JSON.stringify(routeShape.slice(0, 2)) : null;\n  useEffect(() => {\n    // Skip if processing is in progress or if this is the same route\n    if (processingRef.current || routeIdRef.current === currentRouteId && fittedRef.current) {\n      return;\n    }\n\n    // Only fit bounds if we have a valid route shape with points\n    if (routeShape && routeShape.length > 0) {\n      processingRef.current = true;\n      try {\n        // Use setTimeout to give the browser a chance to breathe\n        setTimeout(() => {\n          try {\n            // Create a bounds object from the route shape\n            const bounds = routeShape.reduce((bounds, point) => {\n              bounds.extend(point);\n              return bounds;\n            }, L.latLngBounds(routeShape[0], routeShape[0]));\n\n            // Fit the map to these bounds with some padding\n            map.fitBounds(bounds, {\n              padding: [50, 50],\n              maxZoom: 15,\n              // Limit max zoom level\n              animate: true\n            });\n            console.log(\"Map fitted to route bounds\");\n\n            // Mark that we've fitted bounds for this route\n            fittedRef.current = true;\n            routeIdRef.current = currentRouteId;\n          } catch (e) {\n            console.error(\"Error fitting map to route:\", e);\n          } finally {\n            processingRef.current = false;\n          }\n        }, 100);\n      } catch (e) {\n        console.error(\"Error in MapEffect timeout:\", e);\n        processingRef.current = false;\n      }\n    }\n  }, [map, routeShape, currentRouteId]);\n\n  // Clean up function\n  useEffect(() => {\n    return () => {\n      processingRef.current = false;\n    };\n  }, []);\n  return null;\n};\n_s(MapEffect, \"wWYBugCGexn/wUFL9bcf+nyOIxY=\", false, function () {\n  return [useMap];\n});\n_c = MapEffect;\nexport default MapEffect;\nvar _c;\n$RefreshReg$(_c, \"MapEffect\");","map":{"version":3,"names":["useEffect","useRef","useMap","L","MapEffect","routeShape","_s","map","fittedRef","routeIdRef","processingRef","currentRouteId","JSON","stringify","slice","current","length","setTimeout","bounds","reduce","point","extend","latLngBounds","fitBounds","padding","maxZoom","animate","console","log","e","error","_c","$RefreshReg$"],"sources":["/home/yaniv/coding/automateLinux/extraApps/publicTransportation/react-public-transportation/src/components/map/MapEffect.js"],"sourcesContent":["import { useEffect, useRef } from 'react';\nimport { useMap } from 'react-leaflet';\nimport L from 'leaflet';\n\n/**\n * Component that handles map effects like fitting to bounds\n */\nconst MapEffect = ({ routeShape }) => {\n  const map = useMap();\n  const fittedRef = useRef(false);\n  const routeIdRef = useRef(null);\n  const processingRef = useRef(false);\n  \n  // Generate a unique ID for the current route to detect changes\n  const currentRouteId = routeShape ? JSON.stringify(routeShape.slice(0, 2)) : null;\n  \n  useEffect(() => {\n    // Skip if processing is in progress or if this is the same route\n    if (processingRef.current || \n       (routeIdRef.current === currentRouteId && fittedRef.current)) {\n      return;\n    }\n    \n    // Only fit bounds if we have a valid route shape with points\n    if (routeShape && routeShape.length > 0) {\n      processingRef.current = true;\n      \n      try {\n        // Use setTimeout to give the browser a chance to breathe\n        setTimeout(() => {\n          try {\n            // Create a bounds object from the route shape\n            const bounds = routeShape.reduce((bounds, point) => {\n              bounds.extend(point);\n              return bounds;\n            }, L.latLngBounds(routeShape[0], routeShape[0]));\n            \n            // Fit the map to these bounds with some padding\n            map.fitBounds(bounds, { \n              padding: [50, 50],\n              maxZoom: 15, // Limit max zoom level\n              animate: true\n            });\n            console.log(\"Map fitted to route bounds\");\n            \n            // Mark that we've fitted bounds for this route\n            fittedRef.current = true;\n            routeIdRef.current = currentRouteId;\n          } catch (e) {\n            console.error(\"Error fitting map to route:\", e);\n          } finally {\n            processingRef.current = false;\n          }\n        }, 100);\n      } catch (e) {\n        console.error(\"Error in MapEffect timeout:\", e);\n        processingRef.current = false;\n      }\n    }\n  }, [map, routeShape, currentRouteId]);\n  \n  // Clean up function\n  useEffect(() => {\n    return () => {\n      processingRef.current = false;\n    };\n  }, []);\n  \n  return null;\n};\n\nexport default MapEffect;\n"],"mappings":";AAAA,SAASA,SAAS,EAAEC,MAAM,QAAQ,OAAO;AACzC,SAASC,MAAM,QAAQ,eAAe;AACtC,OAAOC,CAAC,MAAM,SAAS;;AAEvB;AACA;AACA;AACA,MAAMC,SAAS,GAAGA,CAAC;EAAEC;AAAW,CAAC,KAAK;EAAAC,EAAA;EACpC,MAAMC,GAAG,GAAGL,MAAM,CAAC,CAAC;EACpB,MAAMM,SAAS,GAAGP,MAAM,CAAC,KAAK,CAAC;EAC/B,MAAMQ,UAAU,GAAGR,MAAM,CAAC,IAAI,CAAC;EAC/B,MAAMS,aAAa,GAAGT,MAAM,CAAC,KAAK,CAAC;;EAEnC;EACA,MAAMU,cAAc,GAAGN,UAAU,GAAGO,IAAI,CAACC,SAAS,CAACR,UAAU,CAACS,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,GAAG,IAAI;EAEjFd,SAAS,CAAC,MAAM;IACd;IACA,IAAIU,aAAa,CAACK,OAAO,IACrBN,UAAU,CAACM,OAAO,KAAKJ,cAAc,IAAIH,SAAS,CAACO,OAAQ,EAAE;MAC/D;IACF;;IAEA;IACA,IAAIV,UAAU,IAAIA,UAAU,CAACW,MAAM,GAAG,CAAC,EAAE;MACvCN,aAAa,CAACK,OAAO,GAAG,IAAI;MAE5B,IAAI;QACF;QACAE,UAAU,CAAC,MAAM;UACf,IAAI;YACF;YACA,MAAMC,MAAM,GAAGb,UAAU,CAACc,MAAM,CAAC,CAACD,MAAM,EAAEE,KAAK,KAAK;cAClDF,MAAM,CAACG,MAAM,CAACD,KAAK,CAAC;cACpB,OAAOF,MAAM;YACf,CAAC,EAAEf,CAAC,CAACmB,YAAY,CAACjB,UAAU,CAAC,CAAC,CAAC,EAAEA,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC;;YAEhD;YACAE,GAAG,CAACgB,SAAS,CAACL,MAAM,EAAE;cACpBM,OAAO,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC;cACjBC,OAAO,EAAE,EAAE;cAAE;cACbC,OAAO,EAAE;YACX,CAAC,CAAC;YACFC,OAAO,CAACC,GAAG,CAAC,4BAA4B,CAAC;;YAEzC;YACApB,SAAS,CAACO,OAAO,GAAG,IAAI;YACxBN,UAAU,CAACM,OAAO,GAAGJ,cAAc;UACrC,CAAC,CAAC,OAAOkB,CAAC,EAAE;YACVF,OAAO,CAACG,KAAK,CAAC,6BAA6B,EAAED,CAAC,CAAC;UACjD,CAAC,SAAS;YACRnB,aAAa,CAACK,OAAO,GAAG,KAAK;UAC/B;QACF,CAAC,EAAE,GAAG,CAAC;MACT,CAAC,CAAC,OAAOc,CAAC,EAAE;QACVF,OAAO,CAACG,KAAK,CAAC,6BAA6B,EAAED,CAAC,CAAC;QAC/CnB,aAAa,CAACK,OAAO,GAAG,KAAK;MAC/B;IACF;EACF,CAAC,EAAE,CAACR,GAAG,EAAEF,UAAU,EAAEM,cAAc,CAAC,CAAC;;EAErC;EACAX,SAAS,CAAC,MAAM;IACd,OAAO,MAAM;MACXU,aAAa,CAACK,OAAO,GAAG,KAAK;IAC/B,CAAC;EACH,CAAC,EAAE,EAAE,CAAC;EAEN,OAAO,IAAI;AACb,CAAC;AAACT,EAAA,CA9DIF,SAAS;EAAA,QACDF,MAAM;AAAA;AAAA6B,EAAA,GADd3B,SAAS;AAgEf,eAAeA,SAAS;AAAC,IAAA2B,EAAA;AAAAC,YAAA,CAAAD,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}