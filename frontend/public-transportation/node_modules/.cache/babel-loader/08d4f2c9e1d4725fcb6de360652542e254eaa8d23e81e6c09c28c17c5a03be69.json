{"ast":null,"code":"var _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport { useEffect } from 'react';\nimport { useMapEvents, useMap } from 'react-leaflet';\nimport axios from 'axios';\nexport function TrackMapMovement({\n  setMapCenter\n}) {\n  _s();\n  useMapEvents({\n    moveend: event => {\n      const map = event.target;\n      const center = map.getCenter();\n      setMapCenter([center.lat, center.lng]);\n    }\n  });\n  return null;\n}\n_s(TrackMapMovement, \"Ld/tk8Iz8AdZhC1l7acENaOEoCo=\", false, function () {\n  return [useMapEvents];\n});\n_c = TrackMapMovement;\nexport function UpdateMapView({\n  position\n}) {\n  _s2();\n  const map = useMap();\n  useEffect(() => {\n    map.setView(position, map.getZoom());\n  }, [position, map]);\n  return null;\n}\n_s2(UpdateMapView, \"IoceErwr5KVGS9kN4RQ1bOkYMAg=\", false, function () {\n  return [useMap];\n});\n_c2 = UpdateMapView;\nexport const simplifyAddress = address => {\n  const parts = address.split(',').slice(0, 2);\n  return parts.join(',').trim();\n};\nexport const fetchAddress = async (lat, lon, setAddress) => {\n  try {\n    const response = await axios.get(`https://nominatim.openstreetmap.org/reverse?lat=${lat}&lon=${lon}&format=json&accept-language=he&addressdetails=1&countrycodes=il`);\n    const fullAddress = response.data.display_name || 'Address not found';\n    setAddress(simplifyAddress(fullAddress));\n  } catch (error) {\n    console.error('Error fetching address:', error);\n    setAddress('Error fetching address');\n  }\n};\nexport const findRoute = async (position, destination) => {\n  try {\n    console.log(\"Finding route from:\", position, \"to:\", destination);\n\n    // Validate input coordinates\n    if (!position || !position[0] || !position[1] || !destination || !destination[0] || !destination[1]) {\n      console.error(\"Invalid coordinates for routing:\", {\n        position,\n        destination\n      });\n      return [position, destination]; // Return direct line as fallback\n    }\n\n    // First try to get a direct route\n    const response = await axios.get(`https://api.openrouteservice.org/v2/directions/driving-car`, {\n      params: {\n        api_key: '5b3ce3597851110001cf62489ba3c6e8d4824449975eca1f205d2eec',\n        start: `${position[1]},${position[0]}`,\n        end: `${destination[1]},${destination[0]}`\n      }\n    });\n    if (response.data && response.data.features && response.data.features.length > 0) {\n      const routeGeometry = response.data.features[0].geometry.coordinates;\n      const formattedRoute = routeGeometry.map(([lon, lat]) => [lat, lon]);\n      console.log(`Found route with ${formattedRoute.length} points`);\n      return formattedRoute;\n    }\n\n    // If no route is found, create a simple straight line from position to destination\n    console.log(\"No route found via API, creating direct line\");\n    return [[position[0], position[1]], [destination[0], destination[1]]];\n  } catch (error) {\n    console.error('Error finding route:', error);\n    // Return a fallback straight line route on error\n    return [[position[0], position[1]], [destination[0], destination[1]]];\n  }\n};\nvar _c, _c2;\n$RefreshReg$(_c, \"TrackMapMovement\");\n$RefreshReg$(_c2, \"UpdateMapView\");","map":{"version":3,"names":["useEffect","useMapEvents","useMap","axios","TrackMapMovement","setMapCenter","_s","moveend","event","map","target","center","getCenter","lat","lng","_c","UpdateMapView","position","_s2","setView","getZoom","_c2","simplifyAddress","address","parts","split","slice","join","trim","fetchAddress","lon","setAddress","response","get","fullAddress","data","display_name","error","console","findRoute","destination","log","params","api_key","start","end","features","length","routeGeometry","geometry","coordinates","formattedRoute","$RefreshReg$"],"sources":["/home/yaniv/coding/publicTransportation/react-public-transportation/src/components/map/MapUtilities.js"],"sourcesContent":["import { useEffect } from 'react';\nimport { useMapEvents, useMap } from 'react-leaflet';\nimport axios from 'axios';\n\nexport function TrackMapMovement({ setMapCenter }) {\n  useMapEvents({\n    moveend: (event) => {\n      const map = event.target;\n      const center = map.getCenter();\n      setMapCenter([center.lat, center.lng]);\n    },\n  });\n  return null;\n}\n\nexport function UpdateMapView({ position }) {\n  const map = useMap();\n  useEffect(() => {\n    map.setView(position, map.getZoom());\n  }, [position, map]);\n  return null;\n}\n\nexport const simplifyAddress = (address) => {\n  const parts = address.split(',').slice(0, 2);\n  return parts.join(',').trim();\n};\n\nexport const fetchAddress = async (lat, lon, setAddress) => {\n  try {\n    const response = await axios.get(\n      `https://nominatim.openstreetmap.org/reverse?lat=${lat}&lon=${lon}&format=json&accept-language=he&addressdetails=1&countrycodes=il`\n    );\n    const fullAddress = response.data.display_name || 'Address not found';\n    setAddress(simplifyAddress(fullAddress));\n  } catch (error) {\n    console.error('Error fetching address:', error);\n    setAddress('Error fetching address');\n  }\n};\n\nexport const findRoute = async (position, destination) => {\n  try {\n    console.log(\"Finding route from:\", position, \"to:\", destination);\n\n    // Validate input coordinates\n    if (!position || !position[0] || !position[1] || \n        !destination || !destination[0] || !destination[1]) {\n      console.error(\"Invalid coordinates for routing:\", { position, destination });\n      return [position, destination]; // Return direct line as fallback\n    }\n\n    // First try to get a direct route\n    const response = await axios.get(\n      `https://api.openrouteservice.org/v2/directions/driving-car`,\n      {\n        params: {\n          api_key: '5b3ce3597851110001cf62489ba3c6e8d4824449975eca1f205d2eec',\n          start: `${position[1]},${position[0]}`,\n          end: `${destination[1]},${destination[0]}`,\n        },\n      }\n    );\n\n    if (response.data && response.data.features && response.data.features.length > 0) {\n      const routeGeometry = response.data.features[0].geometry.coordinates;\n      const formattedRoute = routeGeometry.map(([lon, lat]) => [lat, lon]);\n      console.log(`Found route with ${formattedRoute.length} points`);\n      return formattedRoute;\n    }\n    \n    // If no route is found, create a simple straight line from position to destination\n    console.log(\"No route found via API, creating direct line\");\n    return [\n      [position[0], position[1]],\n      [destination[0], destination[1]]\n    ];\n  } catch (error) {\n    console.error('Error finding route:', error);\n    // Return a fallback straight line route on error\n    return [\n      [position[0], position[1]],\n      [destination[0], destination[1]]\n    ];\n  }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}