{"ast":null,"code":"import L from 'leaflet';\n\n/**\n * Simplifies a polyline by reducing the number of points\n * Uses the Ramer-Douglas-Peucker algorithm\n * @param {Array} points - Array of [lat, lng] coordinates\n * @param {Number} tolerance - Higher values mean more simplification\n * @returns {Array} - Simplified array of points\n */\nexport function simplifyShape(points, tolerance = 0.0001) {\n  if (!points || points.length <= 2) return points;\n\n  // Create map instance at the beginning so it's available to all inner functions\n  const dummyMap = L.map(document.createElement('div'));\n  const rdp = (pts, start, end, epsilon) => {\n    // Find the point with the maximum distance\n    let dmax = 0;\n    let index = 0;\n    const line = L.polyline([pts[start], pts[end]]);\n    const lineLatLngs = line.getLatLngs();\n    for (let i = start + 1; i < end; i++) {\n      const point = L.latLng(pts[i]);\n      const distance = L.GeometryUtil.distanceSegment(dummyMap, point, lineLatLngs[0], lineLatLngs[1]);\n      if (distance > dmax) {\n        index = i;\n        dmax = distance;\n      }\n    }\n\n    // If max distance is greater than epsilon, recursively simplify\n    const result = [];\n    if (dmax > epsilon) {\n      const res1 = rdp(pts, start, index, epsilon);\n      const res2 = rdp(pts, index, end, epsilon);\n\n      // Concat the results, removing the duplicate point\n      result.push(...res1.slice(0, -1));\n      result.push(...res2);\n    } else {\n      result.push(pts[start]);\n      result.push(pts[end]);\n    }\n    return result;\n  };\n\n  // Simple decimation as fallback - keep only every nth point\n  const decimate = (pts, factor = 4) => {\n    return pts.filter((_, idx) => idx % factor === 0 || idx === pts.length - 1);\n  };\n  try {\n    // First do simple decimation to reduce the number of points\n    const decimated = points.length > 500 ? decimate(points) : points;\n\n    // If we still have a lot of points, use RDP algorithm\n    if (decimated.length > 300) {\n      // For very large datasets, increase the tolerance\n      const adjustedTolerance = tolerance * Math.log10(decimated.length);\n      const simplified = rdp(decimated, 0, decimated.length - 1, adjustedTolerance);\n      dummyMap.remove(); // Clean up the map\n      return simplified;\n    }\n    dummyMap.remove(); // Make sure to clean up\n    return decimated;\n  } catch (err) {\n    console.error('Error simplifying route shape:', err);\n    // Clean up the map in case of error\n    dummyMap.remove();\n    // Fall back to simple decimation\n    return decimate(points, 6);\n  }\n}","map":{"version":3,"names":["L","simplifyShape","points","tolerance","length","dummyMap","map","document","createElement","rdp","pts","start","end","epsilon","dmax","index","line","polyline","lineLatLngs","getLatLngs","i","point","latLng","distance","GeometryUtil","distanceSegment","result","res1","res2","push","slice","decimate","factor","filter","_","idx","decimated","adjustedTolerance","Math","log10","simplified","remove","err","console","error"],"sources":["/home/yaniv/101_coding/publicTransportation/react-public-transportation/src/utils/ShapeSimplifier.js"],"sourcesContent":["import L from 'leaflet';\n\n/**\n * Simplifies a polyline by reducing the number of points\n * Uses the Ramer-Douglas-Peucker algorithm\n * @param {Array} points - Array of [lat, lng] coordinates\n * @param {Number} tolerance - Higher values mean more simplification\n * @returns {Array} - Simplified array of points\n */\nexport function simplifyShape(points, tolerance = 0.0001) {\n  if (!points || points.length <= 2) return points;\n  \n  // Create map instance at the beginning so it's available to all inner functions\n  const dummyMap = L.map(document.createElement('div'));\n  \n  const rdp = (pts, start, end, epsilon) => {\n    // Find the point with the maximum distance\n    let dmax = 0;\n    let index = 0;\n    \n    const line = L.polyline([pts[start], pts[end]]);\n    const lineLatLngs = line.getLatLngs();\n    \n    for (let i = start + 1; i < end; i++) {\n      const point = L.latLng(pts[i]);\n      const distance = L.GeometryUtil.distanceSegment(dummyMap, point, lineLatLngs[0], lineLatLngs[1]);\n      if (distance > dmax) {\n        index = i;\n        dmax = distance;\n      }\n    }\n    \n    // If max distance is greater than epsilon, recursively simplify\n    const result = [];\n    if (dmax > epsilon) {\n      const res1 = rdp(pts, start, index, epsilon);\n      const res2 = rdp(pts, index, end, epsilon);\n      \n      // Concat the results, removing the duplicate point\n      result.push(...res1.slice(0, -1));\n      result.push(...res2);\n    } else {\n      result.push(pts[start]);\n      result.push(pts[end]);\n    }\n    \n    return result;\n  };\n  \n  // Simple decimation as fallback - keep only every nth point\n  const decimate = (pts, factor = 4) => {\n    return pts.filter((_, idx) => idx % factor === 0 || idx === pts.length - 1);\n  };\n  \n  try {\n    // First do simple decimation to reduce the number of points\n    const decimated = points.length > 500 ? decimate(points) : points;\n    \n    // If we still have a lot of points, use RDP algorithm\n    if (decimated.length > 300) {\n      // For very large datasets, increase the tolerance\n      const adjustedTolerance = tolerance * Math.log10(decimated.length);\n      const simplified = rdp(decimated, 0, decimated.length - 1, adjustedTolerance);\n      dummyMap.remove(); // Clean up the map\n      return simplified;\n    }\n    \n    dummyMap.remove(); // Make sure to clean up\n    return decimated;\n  } catch (err) {\n    console.error('Error simplifying route shape:', err);\n    // Clean up the map in case of error\n    dummyMap.remove();\n    // Fall back to simple decimation\n    return decimate(points, 6);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}